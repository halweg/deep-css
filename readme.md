# deepcss

## 基础回顾

### 1.层叠，优先级和继承

- 层叠

	- 层叠三步骤之一：
1.样式表的来源

		- 用户代理样式

			- 就是默认样式

		- !important声明

			- 优先级顺序：
(1) 作者的！important
(2) 作者
(3) 用户代理

	- 层叠三步骤之二：
2.选择器优先级

		- 选择器优先级

			- 总的来说：
ID > 类 > 标签

		- 准确描述

			- 如果选择器的ID数量更多，则它会胜出
			-  如果ID数量一致，那么拥有最多类的选择器胜出
			- 如果以上两次比较都一致，那么拥有最多标签名的选择器胜出
			- 如果以上都都都一致， 
那么按照源码的顺序由近及远来
			- 重要的补充

				- 伪类选择器（如：hover）
和属性选择器（如[type="input"]）
与一个类选择器的优先级相同
				- 通用选择器（＊）和组合器（>、+、~）对优先级没有影响

		- 优先级标记

			- 一个常用的表示优先级的方式是用数值形式来标记
			- 例如1个ID, 2个class, 3个标签，那么优先级就为 :  1,2,3 

		- 关于优先级的思考

	- 层叠三步骤之三：
3.源码顺序

		- 由近及远
链接样式和源码顺序

			- 后声明的比先声明的更优先

		- 层叠值

			- 在层叠中胜出的那个声明，
就是一个层叠值
			- 作为层叠结果，应用到一个元素上的特定属性的值

	- 两条经验法则

		- 在选择器中不要使用ID
		- 不要使用     !important

- 继承

	- 如果一个元素的某个属性没有层叠值，
则可能会继承某个祖先元素的值
	- 但不是所有的层叠值都能被继承
	- 能被继承的层叠值

		- 主要是文本

			- color、font、font-family、font-size、font-weight、font-variant、font-style、line-height、letter-spacing、text-align、text-indent、text-transform、white-space以及word-spacing

		- 列表属性也能被继承

			- list-style、list-style-type、list-style-position以及list-style-image

		- 表格的边框属性也能继承
注意这里不是div

			- border-collapse和border-spacing

- 特殊值

	- inherit关键字

		- 用继承代替一个层叠值
		- 使用inherit关键字强制继承一个通常不会被继承的属性，比如边框和内边距

	- initial关键字

		- 有时，你需要撤销作用于某个元素的样式。这可以用initial关键字来实现。
		- 每一个CSS属性都有初始（默认）值。如果将initial值赋给某个属性，那么就会有效地将其重置为默认值
		- 小心auto值

			- auto，其实就是浏览器默认层叠值
			- auto 对于某些元素来说，不合法

- 简写属性
简写属性是用于同时给多个属性赋值的属性。

	- 常见

		- font

			- 简写的顺序：
font-style、font-weight、font-size、font-height、font-family

		- background

			- 简写的顺序
border-width、border-style以及border-color

		- border

			-  border是border-width、border-style以及border-color的简写属性

		- border-width

			- border-width是上、右、下、左四个边框宽度的简写属性

	- 简写属性带来的问题

		- 简写属性会默默覆盖其他样式：
被简写的属性如果被省略了，缺省属性则会隐式的被定义为 浏览器默认值

	- 理解简写值的顺序

		- 1．上、右、下、左
		- 2．水平、垂直
如果只写了2个属性键值

- 总结

	- ❑ 控制选择器的优先级。
❑ 不要混淆层叠和继承。
❑ 某些属性会被继承，包括文本、列表、表格边框相关的属性。
❑ 不要混淆initial和auto值。
❑ 简写属性要注意TRouBLe的顺序，避免踩坑

### 2.相对单位

- 概要

	- 广泛用途
	- em和rem
	- 视口
	- css变量

- 相对值的好处

	- css的后期绑定

		- 直到内容和样式都完成之后，二者才会结合起来。
		- 早期的cs和传统行业中，开发人员明确的知道媒介屏幕的大小

	- 旧时代的像素级

		- 像素级完美

			- 早期屏幕尺寸单一，

开发者可以创造一个固定大小的容器来限制这种复杂性

		- 像素级完美的终结

			- 高清显示器
			- 智能手机的普及等等，
使开发者再也无法忽视这种差异
			- css中的绝对长度单位

				- px
				- pt（印刷术语 点，1/72英寸）
				- cm厘米
				- in英寸
				- pc（印刷术语，12点）
				- 1in =  25.4mm = 2.54cm = 6pc = 72pt = 96px

		- 像素的误导

			- css像素并不严格等于显示器的像素，
尤其是在视网膜屏下。
在某些设备上浏览器尽管会有一些缩放，但是
96px = 1 物理英寸这个规律，通常下是成立对 

- em和rem

	- em

		- em的概述

			- 最常见的长度单位之一
适合基于特定的字号进行排版

				- 在css中，
1em等于当前元素的字号的大小
				- em的最终值取决于它所作用的元素

			- 浏览器会根据相对单位的的值计算出绝对值，
称作计算值
			- 当设置padding、height、width、border-radius等属性时，使用em会很方便

		- 使用em定义字号

			- 谈到font-szie时，em表现得不太一样


				- 使用em来定义字号的时候，
他根据继承来的字号计算绝对值

			- em同时用于字号和其他属性

				- 首先浏览器根据继承来的字号来计算出font-size,然后再根据font-szie计算出其他属性

			- 字体缩小的问题

				- 当用em来指定多重嵌套元素的字号时，会产生意外的结果
				- 不断沿着dom树找原始字号，字越来越小

		- 既然em在字号上如此难以驾驭，
我们有更好的选择，rem

	- rem
使用rem来设置字号

		- rem是root em的缩写
		- 我一般会用rem设置字号，用px设置边框，用em设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）。

	- 提示

		- 提示拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。

- 停止像素思维
- 视口和相对单位

	- 视口和一些新的相对单位

		- 视口

			- 浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏

		- 相对单位

			- vh

				- 视口高度的1/100

			- vw

				- 视口宽度的1/100

			- vmin

				- 视口宽，高中较小一方的1/100

			- vmax

				- 视口宽，高中较大一方的1/100

	- 使用vw定义字号

		- 如果用vw给一个元素加上
font-size:2vw,则：
在不同的屏幕上，她会有不同大小，当视口大小改变时，元素会逐渐过渡
		- 但是2vw在大屏上太大，在小屏上又太小，怎么办，想保留这种平滑的过渡，又想让这种极端情况缓和怎么办？
使用 calc()

	- 使用calc()定义字号

		- calc()函数内可以对两个及其以上的值进行基本运算
		- 当要结合不同单位的值时，calc()特别实用。它支持的运算包括：加（+）、减（−）、乘（×）、除（÷）


		- 加号和减号两边必须有空白，因此我建议大家养成在每个操作符前后都加上一个空格的习惯，比如calc(1em + 10px)
		- :root {
    font-szie : calc(0.5em + 1vw);
}

			- 0.5em保证了最小字号

同时1vm又保证了字体会随视口的大小进行缩放

- 无单位的数值和行高

	- 有哪些

		- 有些属性允许无单位的值

			- line-height、z-index、font-weight（700等于bold,400等于normal，等等）。
			- 任何长度单位（如px、em、rem）都可以用无单位的值0

	- line-height属性比较特殊，它的值既可以有单位也可以无单位。通常我们应该使用无单位的数值

		- line-height尽量使用无单位的值
		- 因为行高可以被继承，
如段落字号32px, 它继承了行高1.2，那么行高被从新计算为（32 * 1.2 ）px，

		- 当一个元素的值定义为长度（px、em、rem，等等）时，子元素会继承它的计算值。当使用em等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height属性，就会造成意想不到的结果，比如文字重叠

- 自定义属性：css变量

	- 2015年的候选推荐标准

		- 叫层叠变量的自定义属性
		- 案例：
:root {
  --main-font: Hevetica, Arial, sans-serif;
  --brand-color: #369;
}
p {
  font-family : var(--main-font);
  color: var(--brand-color, blue);
  //第二个值是默认值
}


	- 动态改变自定义属性

		- css变量可以在选择器内部被重新定义，
而外部不受影响

	- 使用js动态改变

		- element.setProperty('--main-bg', "#fff");

### 3.box model

## 布局

### 4.float

### 5.flex

### 6.网格

### 8.响应式

### 7.定位和层叠上下文

## 工程化

### 9.模块化

### 10.模式库

## 动效和过渡

### 14.过渡

### 15.变换

### 16.动画

## 高级话题/设计感

### 11.背景，阴影和混合

### 12.对比，颜色和间距

### 13.排版

*XMind - Trial Version*